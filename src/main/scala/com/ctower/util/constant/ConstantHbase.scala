package com.ctower.util

object ConstantHbase {

  val PROPFILE = "hdfs:///BDE/ControlTower/AppILPL/Properties/config.properties"
  //val PROPFILE = "hdfs:///user/datalake/ajangid/HbaseProcessing/HarshaTest/Properties/config.properties"
  val APP_NAME = "ApplicationName"
  val DEPLOY_MODE = "DeployMode"
  val DYNAMIC_ALLOCATION = "spark.dynamicAllocation.enabled"
  val DRIVER_MEMORY = "spark.driver.memory"
  val EXECUTOR_MEMORY = "spark.executor.memory"
  val EXECUTOR_CORE = "spark.executor.cores"
  val NUM_EXECUTOR = "spark.executor.instances"
  val SPECULATIVE_EXECUTION = "speculation"
  val MAX_ATTEMPTS = "attempts"
  val FAILURE_INTERVAL = "failurevalidity"
  val MAX_FAILURES = "maxfailures"
  val KEYTAB_PRINCIPAL = "principal"
  val KEYTAB = "keytab"
  val HBASE_AUTH = "hbaseauthentication"
  val LOGGER_NAME = "logger"
  val LOG_PROP = "logprop"
  val TEMP_PATH = "temppath"
  val STREAM_PATH = "streampath"
  val FINALPATH = "finalpath"
  val BATCH_INTER = "interbatch"
  val ARCHIVEPATH = "archivepath"
  val MST_PRIMARY = "mstprm"
  val MST_BACKUP = "mstbkp"
  val KRB5_CONF = "krb5conf"
  val KRB5_REALM = "krb5realm"
  val KRB5_KDC = "krb5kdc"
  val KEYTAB_FILE = "keytabfile"
  val HBASE_CLUSTER = "clusterdstb"
  val RPC_AUTH = "rpcauth"
  val HBASE_RETRY = "retry"
  val KERBEROS_PRINCIPAL ="kerbprinc"
  val ZKQUORUM = "zkquorum"
  val ZKPORT = "zkport"
  val COMPACTION = "compaction"
  val AWBID = "awbid"
  val IL_AWBNO = "il_awbno"
  val PL_CALLPUS = "pl_callpus"
  val PL_AWBNO="pl_awbno"
  val IL_COAWBNO = "il_coawbno"
  val PL_COAWBNO = "pl_coawbno"
  val BATCH_CNTL = "batch_cntl"
  val CLOSURE_CODES = "closure_codes"

}
